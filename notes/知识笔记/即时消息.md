### 即时消息

#### 安全性

- 访问入口安全
- 传输链路安全



#### 未读数信息

- 会话未读
- 总未读



#### 为什么大部分的IM系统会通过长连接的方式来建立收发双方的通信通道？



- 长连接的方式相比于短链接轮询，能节约不必要的资源开销
- 通过服务端推送，提供更加实时的消息下发
- 省略了TCP握手和TLS握手的几个RTT的时间消耗，在用户体验和实时性上会更好





#### 为什么需要心跳机制

我们知道长连接底层使用的是TCP协议，并不是一个真正存在的物理连接，实际上只是一个无感知的虚拟连接。中间链路的断开，连接两端是不会感知到，因此维护好这个长连接的一个关键问题**就是能够让这个长连接能够在中间链路出了问题**让连接的两端能够快速的得到通知，然后通过重连来重新建立新的可用连接，从而让我们这个长连接一致保持高可用的状态。

- ##### 支持客户端断线重连

- ##### 连接保活



#### 心跳检测的集中实现方式



- ##### TCP Keepalive

  ​		TCP的Keepalive作为操作系统的TCP/IP协议栈实现的一部分，对于本机的TCP连接，会在连接空闲期按一定的频次，自动发送不携带数据的探测报文，来探测对方是否存活，操作系统默认是关闭这个特性的，需要由应用层来开启。

  ​		默认的三个配置项：心跳周期是2小时，失败后再重试9次，超时时间75s，三个配置项都是可以调整。

  ​		在TCP的keepalive已经有实现了，不需要其他的开发工作量，用来作为连接存活与否的探测机制是非常方便的，上层应用只需要处理探测后的连接异常就可以了，而且心跳包不携带数据，带宽资源的浪费也是最少的。

  

  ​		**存在的缺陷**：虽然拥有众多的优势，但是他本身的设计还是存在一些缺陷的，比如心跳间隔灵活性较差，一台服务器某事件只能调整未固定间隔的心跳；另外他虽然能够用于连接层的探测，但是并不代表真正的应用层处于可用状态。

  

- ##### 应用层心跳

  ​	为了解决TCP keepalive存在的不足的问题，使用应用层心跳来提高探针的灵活性和准确性，**应用层心跳实际商就是客户端每过一段时间间隔，就想IM服务端发送一个业务层的数据包告知自己存活。**

  ​		由于不属于TCP/IP协议的实现，所以会有额外的数据传输消耗，但是大部分都十分精简，只传输一个空包或者只携带心态哦间隔。

  ​		相较于TCP keepalive，由于需要在应用层进行发送和接收的处理，因此更能反映应用的可用性，而不是仅仅代表网络可用。并且可以根据实际网络的情况，来灵活的设置心跳间隔，

  ![image-20200426011055331](C:\Users\LB\AppData\Roaming\Typora\typora-user-images\image-20200426011055331.png)



##### 智能心跳

​	为了避免NAT超时的时间差异性很大，将心跳间隔设置为小于所有网络环境下的NAT超时的最短时间，虽然解决了问题，但是对于设备及其资源来讲无法做到最大程度上的节约。

###### 		什么是智能心跳？

​				就是让心跳间隔能够根据网络环境来自动调整，通过不断自动的调整心跳间隔的方式，逐步逼近NAT的超时临界点，在保证NAT不超时的情况下尽量的节约设备资源。





通过过客户端和 IM 服务端建立的“心跳机制”可以快速自动识别连接是否可用，同时避免运营商 NAT 超时被断开的情况。“心跳机制”解决了以下三方面的问题：

- **降低服务端连接维护无效连接的开销。**
- **支持客户端快速识别无效连接，自动断线重连。**
- **连接保活，避免被运营商 NAT 超时断开。**







