### 并发理论基础



##### 什么是原子性的本质

​	不可分割只是其外在表现，本质是多个资源之间的一致性要求，**操作中间状态对外不可见**。所以：解决原子性问题，本质就是保证这个中间状态对外不可见。

#### 死锁

**死锁的概念**：一组互相计竞争资源的线程因为相互等待，导致永久阻塞的现象。

##### 死锁的条件：（四个条件都满足即死锁，反过来即打破一个条件就避免了死锁的发生）

１、互斥，共享资源 X 和 Y 只能被一个线程占用；

２、占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；

３、不可抢占，其他线程不能强行抢占线程 T1 占有的资源；

４、循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。



##### 如何解决死锁：

互斥无法避免，锁的本质就是互斥。所以可以从其他三点进行：

###### １、破环“占用且等待”，我们可以一次性申请所有的资源，这样就不存在等待资源。

​	第一个想法可以通过一个总控的思想对所有的资源进行一个整合管理，即：抽离一个公用的方法对这个所有需要的资源进行统一加锁解锁处理

​	但是这样我们会发现一个问题，如果在并发不高的情况并且操作耗时不长的情况下是可以的，但是万一并发高或者耗时长的话，就会出现循环上万次才会获取到锁，这样太消耗cpu了。

​	在破坏这个条件的基础下，最好的方案应该是如果**线程需要的资源不满足，则线程自己阻塞，进入等待状态，当线程要求的条件满足后，通知等待的线程继续操作，**使用线程阻塞能避免等待消耗CPU的问题。

###### 2、破环不可抢占条件

​	注意的电视synchronized是不支持这个操作的，因为synchronized本质上在申请资源的情况下，如果没有申请到对应的资源就会进入阻塞状态，并不会释放之前占用的资源。可以用并发包下的Lock进行控制

###### 3、破环循环等待条件

​	破环这个条件的话，第一点就是需要对现有的资源进行排序，然后按需进行申请资源。

