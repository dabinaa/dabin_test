#### mysql 数据Buffer Pool



![image-20210921004926277](http://typoradabin.oss-cn-shenzhen.aliyuncs.com/img/image-20210921004926277.png)

##### 什么是Buffer Pool:



对数据库执行增删查改操作的时候，实际上主要针对内存里面的Buffer Pool 中的数据进行的，在数据库的所有操作都是先去针对Buffer Pool 的数据执行的，同时配合了后续的redo log 、刷磁盘的机制和操作。



##### 怎么设置Buffer Pool的大小？

​		本质上是一个数据库的一个内存组件，可以理解为他就是一个内存数据结构，所以这个内存数据结构肯定是有一定的大小，不可能无限大的。这个Buffer Pool默认情况下是128MB，所以还是有一点偏小了，所以我们实际在使用过程中调整。

​		如果我们的机器是16核32G，那我们就可以设置Buffer Pool 分配个2GB的内存，只要执行以下命令：

```
		innodb_buffer_pool_size = 2147483648;
```





##### 数据页：Mysql中抽象出来的数据单位

​		数据库的核心数据模型就是表+字段+行的概念。数据库实际的存储不是一行一行的放在Buffer Pool 里面的，而是对数据抽象出来了一个数据页的概念，他把很多行的数据放在了一个数据页里面，也就是说我们磁盘会有很对数据页。可以理解为：**Buffer Pool 中保存的就是一个一个的数据页**

​		磁盘的数据页和Buffer Pool 中的缓存页默认情况下都是16KB，也就是说一页对应了16KB的数据。

​		Buffer Pool中的描述数据大概相当于缓存页大小的百分之五左右，也就是每个描述数据大概是８００个字节左右的大小，假设设置的Buffer Pool 大小是128MB，实际上真正的大小是会超出一些，

![image-20210921235302082](http://typoradabin.oss-cn-shenzhen.aliyuncs.com/img/image-20210921235302082.png)



#####  怎么感知Buffer Pool 中哪些缓存页是空闲的？

​		数据库会给Buffer Pool 设计一个free链表，他是一个双向链表的数据结构，在这个free链表中，每一个节点就是一个空闲的缓存页的描述数据块的地址，也就是说，只要有一个缓存页是空闲的，那么他的描述数据块就会被放入free链表中。

​		另外，这个free链表有一个基础节点，就是他会引用链表的头节点和尾节点，里面存储了链表中有多少个描述数据块的节点，也就是说还存在多少空闲的数据页。

![image-20210922082736264](http://typoradabin.oss-cn-shenzhen.aliyuncs.com/img/image-20210922082736264.png)

##### Buffer Pool 和free中的描述数据会不会重复？

​		其实这个free链表，它本身就是buffer pool 里面的描述数据块组成的，我们可以认为每个描述数据块都有两个指针，分别保存上一个以及下一个节点。

​		其实对于free链表来讲，只有一个基础节点是不属于Buffer Pool 的，他是一个40字节大小的一个节点，存放的就是free链表的头节点的地址，尾节点的地址，以及free链表中当前有多少的节点。

![image-20210922083943570](http://typoradabin.oss-cn-shenzhen.aliyuncs.com/img/image-20210922083943570.png)



##### 如何知道数据页有没有正常被缓存？

​		其实数据库还会有一个哈希表数据结构，他会有表空间号+数据页号，作为一个key ,然后把缓存页（注意是buffer pool 中的缓存页的地址，而不是磁盘的地址）的地址作为value。



##### 怎么处理Buffer Pool 中数据和磁盘不一致的情况？

​		合理而言，不可能所有的缓存页的数据都需要重新刷盘落地到磁盘，因为有些缓存页数据可以缓存之后一直没有修改。所有Mysql通过一个和free链表一样的 **flush 链表** 他本质上也是一个双向链表，通过描述数据中的指针进行调整，如果缓存页数据被编辑后（也就是我们常说的**脏页**）会丢到flush链表，等待数据刷盘。



##### 怎么处理Buffer Pool 中缓存页不够的情况下，怎么处理？

​		显示生活中当口袋满了但是又要装东西的时候，我们就考虑将不需要的东西丢掉或者换一个地方保存，同理到Buffer Pool 中也是一样的，就是说当Buffer Pool 的缓存页满了的时候，我们需要考虑的是清理掉一些缓存页，再将新的数据页缓存起来。但是到底淘汰那些数据就是我们需要考虑的事情。这里我们要引入一个缓存命中率的概念：**简单来讲就是数据页缓存到Buffer Pool 后的使用率。**

​		这里就要再引用一个链表：**LRU链表**， 我们需要通过这个链表来感知到哪些缓存页是最近最少使用的。

​				他的简单原理就是：如果加载了一个数据到缓存页的时候，对应的数据块数据就会保存到LRU的链表头部，只要有数据他就会再LRU 中，打个比方：如果一个缓存页的数据在尾部，但是被查询调用到了他就会挪动到链表的头部去。也就是说：**最近访问的缓存页一定在链表的头部。**

